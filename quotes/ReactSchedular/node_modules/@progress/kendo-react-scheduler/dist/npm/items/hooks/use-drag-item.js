"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var kendo_react_common_1 = require("@progress/kendo-react-common");
var React = require("react");
var context_1 = require("../../context");
var useControlledState_1 = require("../../hooks/useControlledState");
var main_1 = require("../../main");
var utils_1 = require("../../utils");
/**
 * Represents the available `action` types for the `SchedulerItemDragItemAction` objects.
 *
 * The available types are:
 * - `DRAG_ITEM_SET'`
 * - `DRAG_ITEM_START'`
 * - `DRAG_ITEM_DRAG'`
 * - `DRAG_ITEM_COMPLETE'`
 * - `DRAG_ITEM_COMPLETE_OCCURRENCE'`
 * - `DRAG_ITEM_COMPLETE_SERIES'`
 * - `DRAG_ITEM_RESET'`
 * - `DRAG_ITEM_DRAG_SELECTED`
 */
var DRAG_ITEM_ACTION;
(function (DRAG_ITEM_ACTION) {
    DRAG_ITEM_ACTION["set"] = "DRAG_ITEM_SET";
    DRAG_ITEM_ACTION["start"] = "DRAG_ITEM_START";
    DRAG_ITEM_ACTION["drag"] = "DRAG_ITEM_DRAG";
    DRAG_ITEM_ACTION["complete"] = "DRAG_ITEM_COMPLETE";
    DRAG_ITEM_ACTION["completeOccurrence"] = "DRAG_ITEM_COMPLETE_OCCURRENCE";
    DRAG_ITEM_ACTION["completeSeries"] = "DRAG_ITEM_COMPLETE_SERIES";
    DRAG_ITEM_ACTION["reset"] = "DRAG_ITEM_RESET";
    DRAG_ITEM_ACTION["dragSelected"] = "DRAG_ITEM_DRAG_SELECTED";
})(DRAG_ITEM_ACTION = exports.DRAG_ITEM_ACTION || (exports.DRAG_ITEM_ACTION = {}));
;
/** @hidden */
exports.useDragItem = function (config, state) {
    var offset = React.useRef(0);
    var initialXRef = React.useRef(0);
    var initialYRef = React.useRef(0);
    var oldSlot = React.useRef(null);
    var _a = useControlledState_1.useControlledState.apply(void 0, state), dragItem = _a[0], setDragItem = _a[1];
    var selectedItems = context_1.useSchedulerViewSelectedItemsContext()[0];
    var fields = context_1.useSchedulerFieldsContext();
    var groups = context_1.useSchedulerGroupsContext();
    var handleDragItemAction = function (action) {
        var newDragItem;
        switch (action.type) {
            case DRAG_ITEM_ACTION.set:
                newDragItem = action.payload;
                break;
            case DRAG_ITEM_ACTION.reset:
                newDragItem = null;
                break;
            case DRAG_ITEM_ACTION.dragSelected: {
                if (Math.abs(initialXRef.current - action.payload.x) < 10
                    && Math.abs(initialYRef.current - action.payload.y) < 10) {
                    return;
                }
                var slot = utils_1.slotDive(action.payload.x, action.payload.y, 7);
                if (!slot) {
                    return;
                }
                if (slot === oldSlot.current) {
                    return;
                }
                var dataItem = kendo_react_common_1.clone(config.dataItem);
                var slotStart = slot.getAttribute('data-slot-start');
                var slotIsAllDay = slot.getAttribute('data-slot-allday') === 'true';
                if (!config.ignoreIsAllDay && slotIsAllDay !== config.isAllDay) {
                    return;
                }
                var itemStart = new Date(utils_1.getField(dataItem, fields.start));
                var distance_1 = Number(slotStart) - itemStart.getTime();
                var newDragItems = selectedItems.map(function (si) {
                    if (!si.current) {
                        return null;
                    }
                    var selectedDataItem = kendo_react_common_1.clone(si.current.props.dataItem);
                    var selectedStart = new Date(si.current.props.start.getTime() + distance_1);
                    var selectedEnd = new Date(si.current.props.end.getTime() + distance_1);
                    utils_1.setField(selectedDataItem, fields.start, selectedStart);
                    utils_1.setField(selectedDataItem, fields.end, selectedEnd);
                    return selectedDataItem;
                }).filter(Boolean);
                oldSlot.current = slot;
                newDragItem = newDragItems.slice();
                break;
            }
            case DRAG_ITEM_ACTION.start: {
                var clientX = action.payload.x;
                var clientY = action.payload.y;
                initialXRef.current = clientX;
                initialYRef.current = clientY;
                var slot = utils_1.slotDive(clientX, clientY, 7);
                if (!slot) {
                    return;
                }
                var dataItem = kendo_react_common_1.clone(config.dataItem);
                var slotStart = slot.getAttribute('data-slot-start');
                var itemStart = utils_1.getField(dataItem, fields.start);
                if (slotStart === null) {
                    return;
                }
                offset.current = Number(slotStart) - new Date(itemStart).getTime();
                break;
            }
            case DRAG_ITEM_ACTION.drag: {
                if (Math.abs(initialXRef.current - action.payload.x) < 10
                    && Math.abs(initialYRef.current - action.payload.y) < 10) {
                    return;
                }
                var slot = utils_1.slotDive(action.payload.x, action.payload.y, 7);
                if (!slot) {
                    return;
                }
                if (slot === oldSlot.current) {
                    return;
                }
                var dataItem_1 = kendo_react_common_1.clone(config.dataItem);
                var slotStart = slot.getAttribute('data-slot-start');
                var slotGroupIndex_1 = slot.getAttribute('data-slot-group');
                var slotIsAllDay = slot.getAttribute('data-slot-allday') === 'true';
                if (!config.ignoreIsAllDay && slotIsAllDay !== config.isAllDay) {
                    return;
                }
                var itemStart = new Date(utils_1.getField(dataItem_1, fields.start));
                var itemEnd = new Date(utils_1.getField(dataItem_1, fields.end));
                var duration = itemEnd.getTime() - itemStart.getTime();
                var start = new Date(Number(slotStart) - Number(offset.current));
                var end = new Date(Number(slotStart) - Number(offset.current) + duration);
                var group = groups.find(function (g) { return g.index === Number(slotGroupIndex_1); });
                utils_1.setField(dataItem_1, fields.start, start);
                utils_1.setField(dataItem_1, fields.end, end);
                if (group && groups.length > 1) {
                    group.resources.forEach(function (resource) {
                        if (!resource.multiple) {
                            utils_1.setField(dataItem_1, resource.field, resource[resource.valueField]);
                        }
                    });
                }
                oldSlot.current = slot;
                if (dataItem_1) {
                    newDragItem = dataItem_1;
                }
                break;
            }
            case DRAG_ITEM_ACTION.complete: {
                newDragItem = null;
                if (config.onDataAction && dragItem) {
                    config.onDataAction.call(undefined, {
                        type: main_1.DATA_ACTION.update,
                        series: false,
                        dataItem: dragItem
                    });
                }
                break;
            }
            case DRAG_ITEM_ACTION.completeOccurrence: {
                newDragItem = null;
                var newDataItem = Array.isArray(dragItem) ? dragItem.slice() : kendo_react_common_1.clone(dragItem);
                if (config.onDataAction && dragItem) {
                    config.onDataAction.call(undefined, {
                        type: main_1.DATA_ACTION.update,
                        series: false,
                        dataItem: newDataItem
                    });
                }
                break;
            }
            case DRAG_ITEM_ACTION.completeSeries: {
                newDragItem = null;
                var newDataItems = void 0;
                if (Array.isArray(dragItem)) {
                    newDataItems = dragItem.map(function (di) {
                        var updated = kendo_react_common_1.clone(di);
                        utils_1.setField(updated, fields.start, utils_1.getField(di, fields.start));
                        utils_1.setField(updated, fields.end, utils_1.getField(di, fields.end));
                        return updated;
                    });
                }
                else {
                    var updated = kendo_react_common_1.clone(dragItem);
                    utils_1.setField(updated, fields.start, utils_1.getField(dragItem, fields.start));
                    utils_1.setField(updated, fields.end, utils_1.getField(dragItem, fields.end));
                    newDataItems = updated;
                }
                if (config.onDataAction && newDataItems) {
                    config.onDataAction.call(undefined, {
                        type: main_1.DATA_ACTION.update,
                        series: true,
                        dataItem: newDataItems
                    });
                }
                break;
            }
            default:
                newDragItem = dragItem;
                break;
        }
        setDragItem(newDragItem);
    };
    return [dragItem, setDragItem, handleDragItemAction];
};
//# sourceMappingURL=use-drag-item.js.map