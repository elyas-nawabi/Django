"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var utils_1 = require("../utils");
var kendo_recurrence_1 = require("@progress/kendo-recurrence");
var kendo_date_math_1 = require("@progress/kendo-date-math");
/** @hidden */
exports.capitalize = function (value) { return value.charAt(0).toUpperCase() + value.slice(1); };
/** @hidden */
exports.OFFSET_POSITIONS = ['first', 'second', 'third', 'fourth', 'last'];
/** @hidden */
exports.FREQUENCIES = ['never', 'daily', 'weekly', 'monthly', 'yearly'];
/** @hidden */
exports.dayRule = [
    { day: 0, offset: 0 },
    { day: 1, offset: 0 },
    { day: 2, offset: 0 },
    { day: 3, offset: 0 },
    { day: 4, offset: 0 },
    { day: 5, offset: 0 },
    { day: 6, offset: 0 }
];
/** @hidden */
exports.weekdayRule = [
    { day: 1, offset: 0 },
    { day: 2, offset: 0 },
    { day: 3, offset: 0 },
    { day: 4, offset: 0 },
    { day: 5, offset: 0 }
];
/** @hidden */
exports.weekendRule = [
    { day: 0, offset: 0 },
    { day: 6, offset: 0 }
];
/** @hidden */
exports.weekDayRuleFromString = function (weekDay) {
    switch (weekDay) {
        case 'day':
            return exports.dayRule;
        case 'weekday':
            return exports.weekdayRule;
        case 'weekend':
            return exports.weekendRule;
        default:
            break;
    }
    return;
};
/** @hidden */
exports.getRule = function (recurrenceRule) {
    return kendo_recurrence_1.parseRule({ recurrenceRule: recurrenceRule }) || {};
};
/** @hidden */
exports.getFrequencies = function (localizeMessage) {
    return exports.FREQUENCIES.map(function (freq) { return ({
        value: freq,
        text: localizeMessage('Frequencies' + exports.capitalize(freq))
    }); });
};
/** @hidden */
exports.getFrequency = function (rrule) {
    if (utils_1.isPresent(rrule) && !utils_1.isNullOrEmptyString(rrule.freq)) {
        return rrule.freq;
    }
    return 'never';
};
/** @hidden */
exports.getUntil = function (rrule) {
    if (utils_1.isPresent(rrule.until)) {
        return kendo_date_math_1.toLocalDate(rrule.until);
    }
    return null;
};
/** @hidden */
exports.getMonths = function (intl) {
    return intl.dateFormatNames({
        type: 'months',
        nameType: 'wide'
    }).map(function (month, idx) { return ({
        text: month,
        value: idx + 1
    }); });
};
/** @hidden */
exports.getWeekDays = function (intl) {
    var firstDay = intl.firstDay();
    var abbrNames = intl.dateFormatNames({
        type: 'days',
        nameType: 'abbreviated'
    }).map(function (day, idx) { return ({
        text: day,
        value: idx
    }); });
    /* Sorting according to first week day */
    return (abbrNames.slice(firstDay)).concat(abbrNames.slice(0, firstDay));
};
/** @hidden */
exports.getWeekDay = function (weekDays, rrule, start) {
    return weekDays.find(function (item) {
        var value;
        if (utils_1.isPresent(rrule.byWeekDay)) {
            var weekDaysCount = rrule.byWeekDay.length;
            switch (weekDaysCount) {
                case 7:
                    value = 'day';
                    break;
                case 5:
                    value = 'weekday';
                    break;
                case 2:
                    value = 'weekend';
                    break;
                case 1:
                    value = rrule.byWeekDay[0].day;
                    break;
                default:
                    value = start.getDay();
                    break;
            }
        }
        return value === item.value;
    }) || weekDays[0];
};
/** @hidden */
exports.getExtendedWeekDays = function (intl, localizeMessage) {
    var firstDay = intl.firstDay();
    var wideNames = intl.dateFormatNames({
        type: 'days',
        nameType: 'wide'
    }).map(function (day, idx) { return ({
        text: day,
        value: idx
    }); });
    var sortedWideNames = (wideNames.slice(firstDay)).concat(wideNames.slice(0, firstDay));
    var specialRules = [
        { text: localizeMessage('WeekdaysDay'), value: 'day' },
        { text: localizeMessage('WeekdaysWeekday'), value: 'weekday' },
        { text: localizeMessage('WeekdaysWeekendday'), value: 'weekend' }
    ];
    return specialRules.concat(sortedWideNames);
};
/** @hidden */
exports.getOffset = function (offsets, rrule) {
    return offsets.find(function (offset) { return offset.value === (rrule.bySetPosition
        ? rrule.bySetPosition[0]
        : rrule.byWeekDay && rrule.byWeekDay[0]
            ? rrule.byWeekDay[0].offset
            : 1); }) || offsets[0];
};
/** @hidden */
exports.getOffsets = function (localizeMessage) {
    var values = [1, 2, 3, 4, -1];
    return exports.OFFSET_POSITIONS.map(function (offset, idx) { return ({
        text: localizeMessage('OffsetPositions' + exports.capitalize(offset)),
        value: values[idx]
    }); });
};
/** @hidden */
exports.getEndRule = function (rrule) {
    if (utils_1.isPresent(rrule.count)) {
        return 'count';
    }
    else if (utils_1.isPresent(rrule.until)) {
        return 'until';
    }
    else {
        return 'never';
    }
};
/** @hidden */
exports.getRepeatOnRule = function (rrule) {
    if (utils_1.isPresent(rrule.byWeekDay)) {
        return 'weekday';
    }
    else if (utils_1.isPresent(rrule.byMonthDay)) {
        return 'monthday';
    }
};
/** @hidden */
exports.getMonth = function (months, rrule) {
    return months.find(function (month) { return (rrule.byMonth ? rrule.byMonth[0] : null) === month.value; }) || months[0];
};
/** @hidden */
exports.getMonthDay = function (rrule, start) {
    if (utils_1.isPresent(rrule.byMonthDay) && rrule.byMonthDay.length > 0) {
        return rrule.byMonthDay[0];
    }
    else {
        return start.getDate();
    }
};
/** @hidden */
exports.getUntilEnd = function (start, until) {
    var currentStart = start;
    var currentUntil = until;
    if (utils_1.isPresent(currentUntil)) {
        return currentUntil;
    }
    else {
        return new Date(currentStart.getFullYear(), currentStart.getMonth(), currentStart.getDate(), 23, 59, 59);
    }
};
/** @hidden */
exports.getUntilMin = function (start, until) {
    var currentStart = start;
    var currentUntil = until;
    if (utils_1.isPresent(currentUntil) && currentUntil < currentStart) {
        return currentUntil;
    }
    else {
        return currentStart;
    }
};
//# sourceMappingURL=common.js.map